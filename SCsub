Import('env')

module_env = env.Clone()

# Add your module's source files
module_env.add_source_files(env.modules_sources, [
    "register_types.cpp",
    "thirdparty/flecs/distr/flecs.c",
    "ecs/flecs_types/flecs_query.cpp",
    "ecs/flecs_types/flecs_script_system.cpp",
    "ecs/systems/pipeline_manager.cpp",
    "ecs/utility/navigation2d_utility.cpp",
    "ecs/utility/navigation3d_utility.cpp",
    "ecs/utility/physics2d_utility.cpp",
    "ecs/utility/physics3d_utility.cpp",
    "ecs/utility/render_utility_2d.cpp",
    "ecs/utility/render_utility_3d.cpp",
    "ecs/utility/resource_object_utility.cpp",
    "ecs/utility/scene_object_utility.cpp",
    "ecs/utility/world_utility.cpp",
    "ecs/systems/demo/bad_apple_system.cpp",
    "ecs/flecs_types/flecs_server.cpp"
])

# Use env.GetModulePath() for the module's root, or env.Dir('.')
# Based on common Godot SCons practices, env.GetModulePath() is often available
# or directly using env.Dir('.') which refers to the current directory of the SCsub.

module_env.Append(CPPPATH=[
    # The current directory of this SCsub (i.e., godot_turbo/)
    env.Dir('.'), # This is the most robust and standard SCons way.

    # Specific third-party library relative to module root
    env.Dir('thirdparty/flecs/distr'),
    env.Dir('thirdparty/concurrentqueue/'),


    # Main ECS subdirectories relative to module root
    env.Dir('ecs'),
    env.Dir('ecs/flecs_types'),
    env.Dir('ecs/components'),
    env.Dir('ecs/utility'),
])

# NOTE: No build-level override for concurrentqueue is applied by default here.
# If we need to force the mutex-fallback, define MCDBGQ_NOLOCKFREE_IMPLICITPRODHASH
# via CPPDEFINES here and provide a compatibility header. Keep the vendored header
# unchanged by default to attempt to reproduce earlier runtime behavior.

# Optional optimizations
# module_env.Append(CCFLAGS=["-O2"])
