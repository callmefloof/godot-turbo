void BadAppleSystem::start() {
    if(!world) {
        ERR_PRINT_ONCE("World is not set for BadAppleSystem.");
        return;
    }
    if (!video_player) {
        ERR_PRINT_ONCE("Video player is not set for BadAppleSystem.");
        return;
    }
    if (!mm_entity.is_valid()) {
        ERR_PRINT_ONCE("MM entity is not set for BadAppleSystem.");
        return;
    }
    // Validate MultiMeshComponent exists before creating systems
    if(!mm_entity.is_alive()) {
        ERR_PRINT_ONCE("MM entity is not alive for BadAppleSystem.");
        return;
    }
    if(!mm_entity.has<MultiMeshComponent>()) {
        ERR_PRINT_ONCE("MM entity does not have MultiMeshComponent for BadAppleSystem.");
        return;
    }
    const MultiMeshComponent& mm_comp = mm_entity.get<MultiMeshComponent>();
    if(!command_handler.is_valid()) {
        ERR_PRINT_ONCE("CommandHandler is not set for BadAppleSystem.");
        return;
    }
	// Fetch the pipeline manager fresh from the server to avoid holding a
	// pointer to a potentially-moved map entry (AHashMap can rehash/move
	// elements which would invalidate stored pointers).
	PipelineManager* pm = FlecsServer::get_singleton()->_get_pipeline_manager(world_id);
	if(!pm) {
		ERR_PRINT_ONCE("PipelineManager is not available for BadAppleSystem.");
		return;
	}

    // Cache the multimesh RID to avoid component lookups in lambdas
    const RID cached_mm_rid = mm_comp.multi_mesh_id;
    
    // System to update image data and prepare chunks for processing
    auto bas_get_image_data = world->system<>().interval(1.0 / 30.0).run([&, cached_mm_rid](flecs::iter it){
        if (!video_player) {
            return;
        }
        
        // Try to start playback if not playing
        if (!video_player->is_playing()) {
            // Check if we have a valid stream first
            Ref<VideoStream> stream = video_player->get_stream();
            if (!stream.is_valid()) {
                static bool printed_no_stream = false;
                if (!printed_no_stream) {
                    ERR_PRINT("BadAppleSystem: VideoStreamPlayer has no stream set. Cannot play video.");
                    printed_no_stream = true;
                }
                return;
            }
            
            // Try to play
            video_player->play();
            
            // Verify it actually started playing
            if (!video_player->is_playing()) {
                static int retry_count = 0;
                static bool printed_cant_play = false;
                retry_count++;
                
                if (!printed_cant_play && retry_count > 10) {
                    ERR_PRINT("BadAppleSystem: VideoStreamPlayer.play() called but video is not playing. Check if video player is in scene tree and stream is valid.");
                    printed_cant_play = true;
                }
                return;
            }
        }
        
        Ref<Texture2D> texture = video_player->get_video_texture();
        if (!texture.is_valid()) {
            return;
        }
        if (texture->get_width() == 0 || texture->get_height() == 0) {
            return;
        }
        
        // OPTIMIZATION: Get image reference (not copy if possible)
        Ref<Image> image = texture->get_image();
        if (!image.is_valid()) {
            return;
        }
        if (image->get_width() == 0 || image->get_height() == 0) {
            return;
        }
        
        // Update image data with direct pointer access (zero-copy)
        image_data.width = image->get_width();
        image_data.height = image->get_height();
        image_data.format = image->get_format();
        image_data.ptr = image->get_data().ptr();  // Direct pointer, no copy!
		
		// Get instance count - avoid .get<>() call by using cached RID
		uint32_t instance_count = RS::get_singleton()->multimesh_get_instance_count(cached_mm_rid);
		if (instance_count == 0) {
			return;
		}
		
		// Allocate shared output buffer once
		if (shared_output_buffer.size() != (int)instance_count) {
			shared_output_buffer.resize(instance_count);
		}
		
		// Initialize chunk entities if needed
		if (!chunks_initialized) {
			// Determine optimal chunk count based on thread count
			uint32_t num_chunks = use_multithreading ? MIN(max_threads, (uint32_t)OS::get_singleton()->get_processor_count()) : 1;
			num_chunks = CLAMP(num_chunks, 1U, 32U);
			
			chunk_entities.clear();
			chunk_entities.resize(num_chunks);
			
			for (uint32_t i = 0; i < num_chunks; ++i) {
				chunk_entities[i] = world->entity();
			}
			
			chunks_initialized = true;
		}
		
		// Distribute work across chunks
		uint32_t num_chunks = chunk_entities.size();
		uint32_t pixels_per_chunk = (instance_count + num_chunks - 1) / num_chunks;
		Color* output_ptr = shared_output_buffer.ptrw();
		
		for (uint32_t i = 0; i < num_chunks; ++i) {
			uint32_t start = i * pixels_per_chunk;
			uint32_t end = MIN((i + 1) * pixels_per_chunk, instance_count);
			
			if (start >= instance_count) {
				// Clear this chunk if we don't need it this frame
				if (chunk_entities[i].has<ImageProcessChunk>()) {
					chunk_entities[i].remove<ImageProcessChunk>();
				}
				continue;
			}
			
			ImageProcessChunk chunk = {};
			chunk.start_index = start;
			chunk.end_index = end;
			chunk.img_data = &image_data;
			chunk.mode = mode;
			chunk.output_ptr = output_ptr;  // Shared buffer
			
			chunk_entities[i].set<ImageProcessChunk>(chunk);
		}
    });
    bas_get_image_data.set_name("BadAppleSystem/UpdateImageData");

	// Multi-threaded system to process pixel chunks in parallel
	auto bas_process_chunks = world->system<ImageProcessChunk>()
		.multi_threaded(use_multithreading)
		.each([this](flecs::entity e, ImageProcessChunk& chunk) {
			const ImageData* img_data = chunk.img_data;
			if (!img_data || !img_data->ptr) {
				// Fill with black
				for (uint32_t idx = chunk.start_index; idx < chunk.end_index; ++idx) {
					chunk.output_ptr[idx] = Color(0, 0, 0, 1);
				}
				return;
			}
			
			// Use fast-path for common formats
			if (img_data->format == Image::FORMAT_RGBA8) {
				process_pixels_rgba8(chunk.start_index, chunk.end_index, img_data->width, img_data->height,
				                     img_data->ptr, chunk.mode, chunk.output_ptr);
			} else if (img_data->format == Image::FORMAT_RGB8) {
				process_pixels_rgb8(chunk.start_index, chunk.end_index, img_data->width, img_data->height,
				                    img_data->ptr, chunk.mode, chunk.output_ptr);
			} else {
				// Fallback to slow path for other formats
				for (uint32_t idx = chunk.start_index; idx < chunk.end_index; ++idx) {
					int x = idx % img_data->width;
					int y = idx / img_data->width;
					
					Color result;
					if (x >= img_data->width || y >= img_data->height) {
						result = Color(0, 0, 0, 1);
					} else {
						// Use the generic get_pixel for uncommon formats
						result = get_pixel(*img_data, x, y);
						
						// Apply mode
						switch (chunk.mode) {
							case BASMode::INVERTED:
								result = Color(1.0f - result.r, 1.0f - result.g, 1.0f - result.b, result.a);
								break;
							case BASMode::RANDOM:
								if (BadAppleSystem::hash_to_float(idx + OS::get_singleton()->get_ticks_msec()) > 0.5f) {
									result = Color(1.0f - result.r, 1.0f - result.g, 1.0f - result.b, result.a);
								}
								break;
							default:
								break;
						}
					}
					
					chunk.output_ptr[idx] = result;
				}
			}
		});
	bas_process_chunks.set_name("BadAppleSystem/ProcessChunks");
	
	// Single-threaded flush system that sends results to RenderingServer
	auto bas_flush_results = world->system<>().run([&, cached_mm_rid](flecs::iter it) {
		// Get instance count from RenderingServer directly
		int rd_count = RS::get_singleton()->multimesh_get_instance_count(cached_mm_rid);
		if (rd_count == 0 || shared_output_buffer.size() == 0) {
			return;
		}
		
		// Send shared buffer directly to RenderingServer (zero-copy from here)
		// Note: We need to copy for the lambda capture, but this is unavoidable
		// for thread safety with the command queue
		PackedColorArray color_array = shared_output_buffer;
		
		command_handler->enqueue_command_unpooled([cached_mm_rid, color_array]() {
			int count = RS::get_singleton()->multimesh_get_instance_count(cached_mm_rid);
			// Batch update - single call per instance is still required by RenderingServer API
			const Color* colors = color_array.ptr();
			for (uint32_t idx = 0; idx < (uint32_t)color_array.size() && idx < (uint32_t)count; ++idx) {
				RS::get_singleton()->multimesh_instance_set_color(cached_mm_rid, idx, colors[idx]);
			}
		});
	});
	bas_flush_results.set_name("BadAppleSystem/FlushResults");

	// Add all systems to pipeline in order
	pm->add_to_pipeline(bas_get_image_data, flecs::OnUpdate);
	pm->add_to_pipeline(bas_process_chunks, flecs::OnUpdate);
	pm->add_to_pipeline(bas_flush_results, flecs::OnUpdate);

}

RID BadAppleSystem::get_mm_entity() const {
    return gd_mm_entity;
}

void BadAppleSystem::set_mm_entity(const RID& rid_mm_entity) {
    gd_mm_entity = rid_mm_entity;
	this->mm_entity = FlecsServer::get_singleton()->_get_entity(rid_mm_entity, world_id);
}

void BadAppleSystem::set_video_player(VideoStreamPlayer *p_video_player) {
    video_player = p_video_player;
}

VideoStreamPlayer *BadAppleSystem::get_video_player() const {
	return video_player;
}

void BadAppleSystem::set_world_id(const RID& p_world_id) {
    world_id = p_world_id;
    world = FlecsServer::get_singleton()->_get_world(world_id);
	PipelineManager* pipeline_ptr = FlecsServer::get_singleton()->_get_pipeline_manager(world_id);
	pipeline_manager = pipeline_ptr;
    command_handler = FlecsServer::get_singleton()->get_render_system_command_handler(world_id);
}

RID BadAppleSystem::get_world_id() const {
    return world_id;
}


Color BadAppleSystem::_get_color_at_ofs(const Image::Format format, const uint8_t *ptr, uint32_t ofs) const {
	switch (format) {
		case Image::FORMAT_L8: {
			float l = ptr[ofs] / 255.0;
			return Color(l, l, l, 1);
		}
		case Image::FORMAT_LA8: {
			float l = ptr[ofs * 2 + 0] / 255.0;
			float a = ptr[ofs * 2 + 1] / 255.0;
			return Color(l, l, l, a);
		}
		case Image::FORMAT_R8: {
			float r = ptr[ofs] / 255.0;
			return Color(r, 0, 0, 1);
		}
		case Image::FORMAT_RG8: {
			float r = ptr[ofs * 2 + 0] / 255.0;
			float g = ptr[ofs * 2 + 1] / 255.0;
			return Color(r, g, 0, 1);
		}
		case Image::FORMAT_RGB8: {
			float r = ptr[ofs * 3 + 0] / 255.0;
			float g = ptr[ofs * 3 + 1] / 255.0;
			float b = ptr[ofs * 3 + 2] / 255.0;
			return Color(r, g, b, 1);
		}
		case Image::FORMAT_RGBA8: {
			float r = ptr[ofs * 4 + 0] / 255.0;
			float g = ptr[ofs * 4 + 1] / 255.0;
			float b = ptr[ofs * 4 + 2] / 255.0;
			float a = ptr[ofs * 4 + 3] / 255.0;
			return Color(r, g, b, a);
		}
		case Image::FORMAT_RGBA4444: {
			uint16_t u = ((uint16_t *)ptr)[ofs];
			float r = ((u >> 12) & 0xF) / 15.0;
			float g = ((u >> 8) & 0xF) / 15.0;
			float b = ((u >> 4) & 0xF) / 15.0;
			float a = (u & 0xF) / 15.0;
			return Color(r, g, b, a);
		}
		case Image::FORMAT_RGB565: {
			uint16_t u = ((uint16_t *)ptr)[ofs];
			float r = (u & 0x1F) / 31.0;
			float g = ((u >> 5) & 0x3F) / 63.0;
			float b = ((u >> 11) & 0x1F) / 31.0;
			return Color(r, g, b, 1.0);
		}
		case Image::FORMAT_RF: {
			float r = ((float *)ptr)[ofs];
			return Color(r, 0, 0, 1);
		}
		case Image::FORMAT_RGF: {
			float r = ((float *)ptr)[ofs * 2 + 0];
			float g = ((float *)ptr)[ofs * 2 + 1];
			return Color(r, g, 0, 1);
		}
		case Image::FORMAT_RGBF: {
			float r = ((float *)ptr)[ofs * 3 + 0];
			float g = ((float *)ptr)[ofs * 3 + 1];
			float b = ((float *)ptr)[ofs * 3 + 2];
			return Color(r, g, b, 1);
		}
		case Image::FORMAT_RGBAF: {
			float r = ((float *)ptr)[ofs * 4 + 0];
			float g = ((float *)ptr)[ofs * 4 + 1];
			float b = ((float *)ptr)[ofs * 4 + 2];
			float a = ((float *)ptr)[ofs * 4 + 3];
			return Color(r, g, b, a);
		}
		case Image::FORMAT_RH: {
			uint16_t r = ((uint16_t *)ptr)[ofs];
			return Color(Math::half_to_float(r), 0, 0, 1);
		}
		case Image::FORMAT_RGH: {
			uint16_t r = ((uint16_t *)ptr)[ofs * 2 + 0];
			uint16_t g = ((uint16_t *)ptr)[ofs * 2 + 1];
			return Color(Math::half_to_float(r), Math::half_to_float(g), 0, 1);
		}
		case Image::FORMAT_RGBH: {
			uint16_t r = ((uint16_t *)ptr)[ofs * 3 + 0];
			uint16_t g = ((uint16_t *)ptr)[ofs * 3 + 1];
			uint16_t b = ((uint16_t *)ptr)[ofs * 3 + 2];
			return Color(Math::half_to_float(r), Math::half_to_float(g), Math::half_to_float(b), 1);
		}
		case Image::FORMAT_RGBAH: {
			uint16_t r = ((uint16_t *)ptr)[ofs * 4 + 0];
			uint16_t g = ((uint16_t *)ptr)[ofs * 4 + 1];
			uint16_t b = ((uint16_t *)ptr)[ofs * 4 + 2];
			uint16_t a = ((uint16_t *)ptr)[ofs * 4 + 3];
			return Color(Math::half_to_float(r), Math::half_to_float(g), Math::half_to_float(b), Math::half_to_float(a));
		}
		case Image::FORMAT_RGBE9995: {
			return Color::from_rgbe9995(((uint32_t *)ptr)[ofs]);
		}

		default: {
			ERR_FAIL_V_MSG(Color(), "Can't get_pixel() on compressed image, sorry.");
		}
	}
}

Color BadAppleSystem::get_pixel(const ImageData& p_image_data, const int x, const int y) const {
    Color color = _get_color_at_ofs(p_image_data.format, p_image_data.ptr, y * p_image_data.width + x);
    return color;
}




void BadAppleSystem::_bind_methods() {
	ClassDB::bind_method(D_METHOD("start"), &BadAppleSystem::start);
	ClassDB::bind_method(D_METHOD("set_mm_entity", "mm_entity"), &BadAppleSystem::set_mm_entity);
	ClassDB::bind_method(D_METHOD("get_mm_entity"), &BadAppleSystem::get_mm_entity);
	ClassDB::bind_method(D_METHOD("set_video_player", "video_player"), &BadAppleSystem::set_video_player);
	ClassDB::bind_method(D_METHOD("get_video_player"), &BadAppleSystem::get_video_player);
	ClassDB::bind_method(D_METHOD("set_world_id", "world_id"), &BadAppleSystem::set_world_id);
	ClassDB::bind_method(D_METHOD("get_world_id"), &BadAppleSystem::get_world_id);
	ClassDB::bind_method(D_METHOD("get_mode"), &BadAppleSystem::get_mode);
	ClassDB::bind_method(D_METHOD("set_mode", "mode"), &BadAppleSystem::set_mode);
	
	// Threading configuration
	ClassDB::bind_method(D_METHOD("set_use_multithreading", "enabled"), &BadAppleSystem::set_use_multithreading);
	ClassDB::bind_method(D_METHOD("get_use_multithreading"), &BadAppleSystem::get_use_multithreading);
	ClassDB::bind_method(D_METHOD("set_threading_threshold", "threshold"), &BadAppleSystem::set_threading_threshold);
	ClassDB::bind_method(D_METHOD("get_threading_threshold"), &BadAppleSystem::get_threading_threshold);
	ClassDB::bind_method(D_METHOD("set_max_threads", "max_threads"), &BadAppleSystem::set_max_threads);
	ClassDB::bind_method(D_METHOD("get_max_threads"), &BadAppleSystem::get_max_threads);

	ADD_PROPERTY(PropertyInfo(Variant::INT, "mode", PROPERTY_HINT_ENUM, "Regular,Inverted,Random"), "set_mode", "get_mode");
	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "use_multithreading"), "set_use_multithreading", "get_use_multithreading");
	ADD_PROPERTY(PropertyInfo(Variant::INT, "threading_threshold", PROPERTY_HINT_RANGE, "1000,1000000,1000"), "set_threading_threshold", "get_threading_threshold");
	ADD_PROPERTY(PropertyInfo(Variant::INT, "max_threads", PROPERTY_HINT_RANGE, "1,32,1"), "set_max_threads", "get_max_threads");

}